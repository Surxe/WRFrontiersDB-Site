---
import fs from 'fs';
import path from 'path';

export async function getStaticPaths() {
  const versionsPath = path.join(process.cwd(), 'WRFrontiersDB-Data/versions.json');
  const versions = JSON.parse(fs.readFileSync(versionsPath, 'utf8'));
  
  const paths = [];
  const moduleVersionsMap = new Map(); // Build lookup table once
  
  // For each version, load its modules and create paths
  for (const version of Object.keys(versions)) {
    try {
      const modulesPath = path.join(process.cwd(), `WRFrontiersDB-Data/archive/${version}/Objects/Module.json`);
      if (fs.existsSync(modulesPath)) {
        const modules = JSON.parse(fs.readFileSync(modulesPath, 'utf8'));
        
        // For each module in this version, create a path and track versions
        for (const [moduleId, module] of Object.entries(modules)) {
          // Skip modules that are not ready for production
          if (!(module as any).production_status || (module as any).production_status === false) {
            continue;
          }
          
          paths.push({ 
            params: { id: moduleId, version },
            props: { 
              moduleVersions: moduleVersionsMap.get(moduleId) || [] 
            }
          });
          
          // Build reverse lookup: which versions have this module
          if (!moduleVersionsMap.has(moduleId)) {
            moduleVersionsMap.set(moduleId, []);
          }
          moduleVersionsMap.get(moduleId).push(version);
        }
      }
    } catch (error) {
      console.warn(`Could not load modules for version ${version}`);
    }
  }
  
  // Update paths with complete version lists
  return paths.map(path => ({
    ...path,
    props: {
      moduleVersions: moduleVersionsMap.get(path.params.id) || []
    }
  }));
}

const { id, version } = Astro.params;
const { moduleVersions } = Astro.props;

let module;
try {
  const modulesPath = path.join(process.cwd(), `WRFrontiersDB-Data/archive/${version}/Objects/Module.json`);
  const modules = JSON.parse(fs.readFileSync(modulesPath, 'utf8'));
  module = modules[id];
} catch (error) {
  throw new Error(`Module not found for version ${version}`);
}

if (!module) {
  throw new Error('Module not found');
}

// Load version metadata (only once per page)
const versionsPath = path.join(process.cwd(), 'WRFrontiersDB-Data/versions.json');
const versions = JSON.parse(fs.readFileSync(versionsPath, 'utf8'));
const versionInfo = versions[version];

// Extract icon filename from inventory_icon_path
let iconSrc = null;
if (module.inventory_icon_path) {
  // Remove the leading slash and extract the path after "WRFrontiers/"
  const iconPath = module.inventory_icon_path;
  iconSrc = `/WRFrontiersDB-Site/WRFrontiersDB-Data/textures${iconPath}.png`;
}

// Extract English text as fallback
const defaultName = module.name?.en || module.id;
const defaultDesc = module.description?.en || '';

// Store localization keys for dynamic loading
const locKeys = {
  name: { key: module.name?.Key, namespace: module.name?.TableNamespace },
  description: { key: module.description?.Key, namespace: module.description?.TableNamespace }
};

---

<html>
  <head>
    <title>{module.id} - {version}</title>
  </head>
  <body>
    <p>Back to <a href="/WRFrontiersDB-Site/modules">Modules</a></p>
    <h1 id="module-name" 
        data-loc-key={locKeys.name.key} 
        data-loc-namespace={locKeys.name.namespace}>
      {defaultName}
    </h1>
    {iconSrc && (
      <img src={iconSrc} alt={`${defaultName} icon`} style="width: 64px; height: 64px;" />
    )}
    <p id="module-desc" 
       data-loc-key={locKeys.description.key} 
       data-loc-namespace={locKeys.description.namespace}>
      {defaultDesc}
    </p>
    <p>Version: {versionInfo?.title || version} ({version})</p>
    <p>Language: <span id="current-lang">en</span></p>

    <div id="stats">stats</div>
    
    <h2>Available Versions</h2>
    <ul>
      {moduleVersions.map((v: string) => (
        <li>
          <a href={`/WRFrontiersDB-Site/modules/${id}/${v}`}>
            {versions[v]?.title || v} ({v})
          </a>
        </li>
      ))}
    </ul>
    
    
    <!-- Embed JSON -->
    <script type="application/json" id="module-data" set:html={JSON.stringify(module)}></script>

    <script is:inline>
      // Localization cache
      const locCache = {};
      
      async function loadLanguage(lang, version) {
        const cacheKey = `${version}-${lang}`;
        if (locCache[cacheKey]) return locCache[cacheKey];
        
        try {
          const response = await fetch(`/WRFrontiersDB-Site/WRFrontiersDB-Data/archive/${version}/Localization/${lang}.json`);
          locCache[cacheKey] = await response.json();
          return locCache[cacheKey];
        } catch (error) {
          console.warn(`Failed to load language ${lang}:`, error);
          return null;
        }
      }
      
      function getLocalizedText(locData, namespace, key) {
        return locData?.[namespace]?.[key] || key;
      }
      
      async function updateLocalization() {
        const currentLang = localStorage.getItem('selectedLang') || 'en';
        const langSpan = document.getElementById('current-lang');
        if (langSpan) {
          langSpan.textContent = currentLang;
        }
        
        // Skip if English (already embedded)
        if (currentLang === 'en') return;
        
        // Get current version from page
        const version = window.location.pathname.split('/').pop();
        
        // Load language file
        const locData = await loadLanguage(currentLang, version);
        if (!locData) return;
        
        // Update module name
        const nameEl = document.getElementById('module-name');
        if (nameEl) {
          const namespace = nameEl.dataset.locNamespace;
          const key = nameEl.dataset.locKey;
          if (namespace && key) {
            const localizedName = getLocalizedText(locData, namespace, key);
            nameEl.textContent = localizedName;
          }
        }
        
        // Update module description
        const descEl = document.getElementById('module-desc');
        if (descEl) {
          const namespace = descEl.dataset.locNamespace;
          const key = descEl.dataset.locKey;
          if (namespace && key) {
            const localizedDesc = getLocalizedText(locData, namespace, key);
            descEl.textContent = localizedDesc;
          }
        }
      }
      
      // Run on page load
      updateLocalization();
    </script>

    <script is:inline src="/WRFrontiersDB-Site/js/module_page.js"></script>
  </body>
</html>
